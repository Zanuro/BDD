-- MySQL Script generated by MySQL Workbench
-- mié 22 ene 2020 12:56:41 WET
-- Model: New Model    Version: 1.0
-- MySQL Workbench Forward Engineering

/*
SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';
*/

-- -----------------------------------------------------
-- Schema OAN
-- -----------------------------------------------------

-- -----------------------------------------------------
-- Schema OAN
-- -----------------------------------------------------
DROP DATABASE oan;
CREATE DATABASE oan ;
\c oan ;

-- -----------------------------------------------------
-- Table categoria
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS categoria (
  idCategoria SERIAL NOT NULL,
  nombre VARCHAR(20) NOT NULL,
  descripcion VARCHAR(60) NOT NULL,
  PRIMARY KEY (idCategoria))
;


-- -----------------------------------------------------
-- Table actor
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS actor (
  idActor SERIAL NOT NULL,
  nombre VARCHAR(30) NOT NULL,
  PRIMARY KEY (idActor))
;


-- -----------------------------------------------------
-- Table titulo
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS titulo (
  idTitulo SERIAL NOT NULL,
  nombre VARCHAR(30) NOT NULL,
  año VARCHAR(4) NOT NULL,
  fecha_expiracion DATE NULL,
  valoracion DECIMAL(3,1) NOT NULL,
  duracion INT NOT NULL,
  precio DECIMAL(18,2) NOT NULL,
  descripcion VARCHAR(100) NOT NULL,
  calidad VARCHAR(20) NOT NULL,
  tipo VARCHAR(45) NOT NULL,
  CHECK (valoracion >= 0.0 AND valoracion <= 10.0),
  CHECK (duracion >= 0),
  PRIMARY KEY (idTitulo))
;


-- -----------------------------------------------------
-- Table usuario
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS usuario (
  email VARCHAR(45) NOT NULL,
  calle VARCHAR(45) NOT NULL,
  numero INT NOT NULL,
  codPostal INT NOT NULL,
  localidad VARCHAR(45) NOT NULL,
  provincia VARCHAR(45) NOT NULL,
  pais VARCHAR(45) NOT NULL,
  fecha_nacimiento DATE NOT NULL,
  nombre VARCHAR(45) NOT NULL,
  apellidos VARCHAR(45) NOT NULL,
  PRIMARY KEY (email))
;


-- -----------------------------------------------------
-- Table perfil
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS perfil (
  idPerfil SERIAL NOT NULL,
  nombre VARCHAR(20) NOT NULL,
  num_descargas_actuales INT NULL DEFAULT 0,
  email VARCHAR(45) NOT NULL,
  idPendientes SERIAL NOT NULL UNIQUE,
  idFavoritos SERIAL NOT NULL UNIQUE,
  CHECK (num_descargas_actuales >= 0),
  PRIMARY KEY (idPerfil),
  CONSTRAINT fk_perfil_email
    FOREIGN KEY (email)
    REFERENCES usuario (email)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
;

CREATE INDEX fk_perfil_1_idx ON perfil (email ASC);

CREATE UNIQUE INDEX idPendientes_UNIQUE ON perfil (idPendientes ASC);

CREATE UNIQUE INDEX idFavoritos_UNIQUE ON perfil (idFavoritos ASC);


-- -----------------------------------------------------
-- Table descargas
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS descargas (
  idTitulo INT NOT NULL,
  fecha_caducidad DATE NOT NULL,
  idPerfil INT NOT NULL,
  PRIMARY KEY (idTitulo, idPerfil),
  CONSTRAINT fk_descargas_idTitulo
    FOREIGN KEY (idTitulo)
    REFERENCES titulo (idTitulo)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_descargas_idPerfil
    FOREIGN KEY (idPerfil)
    REFERENCES perfil (idPerfil)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
;

CREATE INDEX fk_descargas_1_idx ON descargas (idTitulo ASC);

CREATE INDEX fk_descargas_2_idx ON descargas (idPerfil ASC);


-- -----------------------------------------------------
-- Table titulo_categoria
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS titulo_categoria (
  idCategoria INT NOT NULL,
  idTitulo INT NOT NULL,
  PRIMARY KEY (idCategoria, idTitulo),
  CONSTRAINT fk_titulo_categoria_idCategoria
    FOREIGN KEY (idCategoria)
    REFERENCES categoria (idCategoria)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_titulo_categoria_idTitulo
    FOREIGN KEY (idTitulo)
    REFERENCES titulo (idTitulo)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
;

CREATE INDEX fk_titulo_categoria_2_idx ON titulo_categoria (idTitulo ASC);


-- -----------------------------------------------------
-- Table actor_titulo
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS actor_titulo (
  idActor INT NOT NULL,
  idTitulo INT NOT NULL,
  PRIMARY KEY (idActor, idTitulo),
  CONSTRAINT fk_actor_titulo_idActor
    FOREIGN KEY (idActor)
    REFERENCES actor (idActor)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_actor_titulo_idTitulo
    FOREIGN KEY (idTitulo)
    REFERENCES titulo (idTitulo)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
;

CREATE INDEX fk_actor_titulo_2_idx ON actor_titulo (idTitulo ASC);


-- -----------------------------------------------------
-- Table serie
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS serie (
  idSerie SERIAL NOT NULL,
  nombre VARCHAR(20) NOT NULL,
  descripcion VARCHAR(150) NOT NULL,
  PRIMARY KEY (idSerie))
;


-- -----------------------------------------------------
-- Table suscripcion
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS suscripcion (
  idSuscripcion SERIAL NOT NULL,
  fecha_finalizacion DATE NOT NULL,
  num_descargas_max INT NOT NULL,
  tipo_suscripcion VARCHAR(15) NOT NULL,
  email VARCHAR(45) NOT NULL,
  CHECK (num_descargas_max >= 0),
  CHECK (tipo_suscripcion IN ('Basica', 'Premium', 'Contenido')),
  PRIMARY KEY (idSuscripcion),
  CONSTRAINT fk_suscripcion_email
    FOREIGN KEY (email)
    REFERENCES usuario (email)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
;

CREATE INDEX fk_suscripcion_1_idx ON suscripcion (email ASC);


-- -----------------------------------------------------
-- Table factura
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS factura (
  idFactura SERIAL NOT NULL,
  fecha_factura DATE NOT NULL,
  importe DECIMAL(18,2) NOT NULL,
  idSuscripcion INT NOT NULL,
  PRIMARY KEY (idFactura),
  CONSTRAINT fk_factura_idSuscripcion
    FOREIGN KEY (idSuscripcion)
    REFERENCES suscripcion (idSuscripcion)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
;

CREATE INDEX fk_factura_suscripcion_idx ON factura (idSuscripcion ASC);


-- -----------------------------------------------------
-- Table pago
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS pago (
  idPago SERIAL NOT NULL,
  fecha DATE NOT NULL,
  metodo_pago VARCHAR(45) NULL,
  nombre VARCHAR(45) NULL,
  num_tarjeta VARCHAR(45) NULL,
  CVC VARCHAR(45) NULL,
  fecha_vencimiento DATE NULL,
  tipo_pago VARCHAR(45) NULL,
  idFactura INT NOT NULL,
  PRIMARY KEY (idPago),
  CONSTRAINT fk_pago_idFactura
    FOREIGN KEY (idFactura)
    REFERENCES factura (idFactura)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
;

CREATE INDEX fk_pago_1_idx ON pago (idFactura ASC);


-- -----------------------------------------------------
-- Table empleado
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS empleado (
  idEmpleado SERIAL NOT NULL,
  nombre VARCHAR(45) NOT NULL,
  PRIMARY KEY (idEmpleado))
;


-- -----------------------------------------------------
-- Table reporte
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS reporte (
  idReporte SERIAL NOT NULL,
  descripcion VARCHAR(150) NOT NULL,
  estado VARCHAR(20) NULL,
  email VARCHAR(45) NOT NULL,
  PRIMARY KEY (idReporte),
  CONSTRAINT fk_reporte_email
    FOREIGN KEY (email)
    REFERENCES usuario (email)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
;

CREATE INDEX fk_reporte_1_idx ON reporte (email ASC);


-- -----------------------------------------------------
-- Table reporte_empleado
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS reporte_empleado (
  idEmpleado INT NOT NULL,
  idReporte INT NOT NULL,
  PRIMARY KEY (idEmpleado, idReporte),
  CONSTRAINT fk_reporte_empleado_idEmpleado
    FOREIGN KEY (idEmpleado)
    REFERENCES empleado (idEmpleado)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT fk_reporte_empleado_idReporte
    FOREIGN KEY (idReporte)
    REFERENCES reporte (idReporte)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
;

CREATE INDEX fk_reporte_empleado_2_idx ON reporte_empleado (idReporte ASC);


-- -----------------------------------------------------
-- Table redsocial
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS redsocial (
  nombre VARCHAR(30) NOT NULL,
  tipo_red_social VARCHAR(20) NOT NULL,
  idPerfil INT NOT NULL,
  CHECK (tipo_red_social IN ('Facebook', 'Twitter')),
  PRIMARY KEY (idPerfil, tipo_red_social),
  CONSTRAINT fk_redsocial_idPerfil
    FOREIGN KEY (idPerfil)
    REFERENCES perfil (idPerfil)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
;

CREATE INDEX fk_redsocial_1_idx ON redsocial (idPerfil ASC);


-- -----------------------------------------------------
-- Table perfil_perfil
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS perfil_perfil (
  idPerfil INT NOT NULL,
  idPerfilAmigo INT NOT NULL,
  PRIMARY KEY (idPerfil, idPerfilAmigo),
  CONSTRAINT fk_perfil_perfil_idPerfil
    FOREIGN KEY (idPerfil)
    REFERENCES perfil (idPerfil)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_perfil_perfil_idPerfilAmigo
    FOREIGN KEY (idPerfilAmigo)
    REFERENCES perfil (idPerfil)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
;

CREATE INDEX fk_perfil_perfil_2_idx ON perfil_perfil (idPerfilAmigo ASC);


-- -----------------------------------------------------
-- Table perfil_comenta_titulo
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS perfil_comenta_titulo (
  idPerfil INT NOT NULL,
  idTitulo INT NOT NULL,
  fecha TIMESTAMP NOT NULL,
  comentario VARCHAR(150) NOT NULL,
  PRIMARY KEY (idPerfil, idTitulo, fecha),
  CONSTRAINT fk_perfil_comenta_titulo_idPerfil
    FOREIGN KEY (idPerfil)
    REFERENCES perfil (idPerfil)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT fk_perfil_comenta_titulo_idTitulo
    FOREIGN KEY (idTitulo)
    REFERENCES titulo (idTitulo)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
;

CREATE INDEX fk_perfil_comenta_titulo_2_idx ON perfil_comenta_titulo (idTitulo ASC);


-- -----------------------------------------------------
-- Table perfil_visualiza_titulo
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS perfil_visualiza_titulo (
  idPerfil INT NOT NULL,
  idTitulo INT NOT NULL,
  momento_actual INT NOT NULL DEFAULT 0,
  visto BOOLEAN NOT NULL DEFAULT FALSE,
  PRIMARY KEY (idPerfil, idTitulo),
  CONSTRAINT fk_perfil_visualiza_titulo_idPerfil
    FOREIGN KEY (idPerfil)
    REFERENCES perfil (idPerfil)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT fk_perfil_visualiza_titulo_idTitulo
    FOREIGN KEY (idTitulo)
    REFERENCES titulo (idTitulo)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
;

CREATE INDEX fk_perfil_visualiza_titulo_2_idx ON perfil_visualiza_titulo (idTitulo ASC);


-- -----------------------------------------------------
-- Table favoritos
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS favoritos (
  idFavoritos INT NOT NULL,
  idTitulo INT NOT NULL,
  PRIMARY KEY (idFavoritos, idTitulo),
  CONSTRAINT fk_favoritos_idTitulo
    FOREIGN KEY (idTitulo)
    REFERENCES titulo (idTitulo)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_favoritos_idFavoritos
    FOREIGN KEY (idFavoritos)
    REFERENCES perfil (idFavoritos)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
;

CREATE INDEX fk_favoritos_idTitulo_idx ON favoritos (idTitulo ASC);


-- -----------------------------------------------------
-- Table pendientes
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS pendientes (
  idPendientes INT NOT NULL,
  idTitulo INT NOT NULL,
  PRIMARY KEY (idPendientes, idTitulo),
  CONSTRAINT fk_pendientes_idTitulo
    FOREIGN KEY (idTitulo)
    REFERENCES titulo (idTitulo)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_pendientes_idPendientes
    FOREIGN KEY (idPendientes)
    REFERENCES perfil (idPendientes)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
;

CREATE INDEX fk_pendientes_1_idx ON pendientes (idTitulo ASC);


-- -----------------------------------------------------
-- Table titulo_serie
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS titulo_serie (
  idTitulo INT NOT NULL,
  capitulo INT NOT NULL,
  temporada INT NOT NULL,
  idSerie INT NOT NULL,
  PRIMARY KEY (idTitulo),
  CONSTRAINT fk_titulo_serie_idSerie
    FOREIGN KEY (idSerie)
    REFERENCES serie (idSerie)
    ON DELETE RESTRICT
    ON UPDATE CASCADE,
  CONSTRAINT fk_titulo_serie_idTitulo
    FOREIGN KEY (idTitulo)
    REFERENCES titulo (idTitulo)
    ON DELETE RESTRICT
    ON UPDATE CASCADE)
;

CREATE INDEX fk_titulo_serie_serie_idx ON titulo_serie (idSerie ASC);


-- -----------------------------------------------------
-- Table idioma
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS idioma (
  idIdioma SERIAL NOT NULL,
  nombre VARCHAR(45) NOT NULL UNIQUE,
  PRIMARY KEY (idIdioma))
;

CREATE UNIQUE INDEX nombre_UNIQUE ON idioma (nombre ASC);


-- -----------------------------------------------------
-- Table subtitulo
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS subtitulo (
  idTitulo INT NOT NULL,
  idIdioma INT NOT NULL,
  PRIMARY KEY (idTitulo, idIdioma),
  CONSTRAINT fk_subtitulo_idTitulo
    FOREIGN KEY (idTitulo)
    REFERENCES titulo (idTitulo)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_subtitulo_idIdioma
    FOREIGN KEY (idIdioma)
    REFERENCES idioma (idIdioma)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
;

CREATE INDEX fk_subtitulo_idioma_idx ON subtitulo (idIdioma ASC);


-- -----------------------------------------------------
-- Table titulo_idioma
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS titulo_idioma (
  idTitulo INT NOT NULL,
  idIdioma INT NOT NULL,
  PRIMARY KEY (idTitulo, idIdioma),
  CONSTRAINT fk_titulo_idioma_idTitulo
    FOREIGN KEY (idTitulo)
    REFERENCES titulo (idTitulo)
    ON DELETE CASCADE
    ON UPDATE CASCADE,
  CONSTRAINT fk_titulo_idioma_idIdioma
    FOREIGN KEY (idIdioma)
    REFERENCES idioma (idIdioma)
    ON DELETE CASCADE
    ON UPDATE CASCADE)
;

CREATE INDEX fk_titulo_idioma_idIdioma_idx ON titulo_idioma (idIdioma ASC);





-- -----------------------------------------------------
-- Triggers
-- -----------------------------------------------------


-- -----------------------------------------------------
-- Antes de INSERTAR/MODIFICAR en la TABLA titulo_serie:
-- Comprueba que el título es una serie
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION comprueba_serie()
RETURNS trigger AS $comprueba_serie$
BEGIN
  -- Comprobar si el título es una serie
  IF NOT EXISTS (SELECT FROM titulo WHERE idTitulo=NEW.idTitulo AND tipo='Serie') THEN
	RAISE EXCEPTION 'Error, El título indicado no es del tipo Serie.';
  END IF;

  RETURN NEW;
END;
$comprueba_serie$ LANGUAGE plpgsql;


CREATE TRIGGER comp_serie
BEFORE INSERT OR UPDATE ON titulo_serie
FOR EACH ROW
EXECUTE PROCEDURE comprueba_serie();


-- -----------------------------------------------------
-- Antes de MODIFICAR en la TABLA titulo_serie:
-- Impide la modificación del tipo serie a otro tipo, si
-- existe una asociación a una serie
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION comprueba_modificacion_tipo_titulo()
RETURNS trigger AS $comprueba_modificacion_tipo_titulo$
BEGIN
  -- Si se modifica el atributo tipo y anteriormente era Serie
  IF OLD.tipo <> NEW.tipo AND OLD.tipo = 'Serie' THEN
    IF EXISTS (SELECT FROM titulo_serie WHERE idTitulo=OLD.idTitulo) THEN
      RAISE EXCEPTION 'Error, No se puede modificar el tipo del título, porque existen registros en la tabla titulo_serie que dependen de él.';
    END IF;
  END IF;

  RETURN NEW;
END;
$comprueba_modificacion_tipo_titulo$ LANGUAGE plpgsql;


CREATE TRIGGER comp_mod_tipo_titulo
BEFORE UPDATE ON titulo
FOR EACH ROW
EXECUTE PROCEDURE comprueba_modificacion_tipo_titulo();



-- -----------------------------------------------------
-- Antes de INSERTAR/MODIFICAR en la TABLA perfil_visualiza_titulo:
-- Marca, si es necesario, el título como visualizado
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION marcar_titulo_visto()
RETURNS trigger AS $marcar_titulo_visto$
DECLARE
  margen CONSTANT INT := 10; -- Margen en minutos, para marcar titulo como visto
  total INT;
BEGIN
  SELECT duracion INTO total
  FROM titulo
  WHERE idTitulo=NEW.idTitulo;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Error, no existe el titulo con id %.', NEW.idTitulo;
  END IF;

  total := (total - margen) * 60; -- Restamos margen y pasamos a segundos

  IF NEW.momento_actual >= total THEN
    -- Marcamos como visto
    NEW.visto = TRUE;
  ELSE
    NEW.visto = FALSE;
  END IF;

  RETURN NEW;
END;
$marcar_titulo_visto$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_marcar_titulo_visto
BEFORE INSERT OR UPDATE ON perfil_visualiza_titulo
FOR EACH ROW
EXECUTE PROCEDURE marcar_titulo_visto();



-- -----------------------------------------------------
-- Antes de INSERTAR en la TABLA perfil_comenta_titulo:
-- Comprueba si el perfil ha visto el título a comentar, si no lo ha visto, cancela
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION comentar_titulo()
RETURNS trigger AS $comentar_titulo$
DECLARE
  visualizado BOOLEAN;
BEGIN

  SELECT visto INTO visualizado
  FROM perfil_visualiza_titulo
  WHERE idTitulo=NEW.idTitulo AND idPerfil=NEW.idPerfil;
  IF NOT FOUND THEN
    visualizado := FALSE;
  END IF;

  IF NOT visualizado THEN
    RAISE EXCEPTION 'Error, No puedes comentar un título que no has visto.';
  END IF;

  RETURN NEW;
END;
$comentar_titulo$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_comentar_titulo
BEFORE INSERT ON perfil_comenta_titulo
FOR EACH ROW
EXECUTE PROCEDURE comentar_titulo();


-- -----------------------------------------------------
-- Antes de INSERTAR/ACTUALIZAR en la TABLA perfil_perfil:
-- Impide la inserción de perfiles amigos de si mismo
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION comprobar_amigo()
RETURNS trigger AS $comprobar_amigo$
BEGIN

  IF NEW.idPerfil = NEW.idPerfilAmigo THEN
    RAISE EXCEPTION 'Error, Un perfil no puede ser amigo de si mismo.';
  END IF;

  RETURN NEW;
END;
$comprobar_amigo$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_comprobar_amigo
BEFORE INSERT OR UPDATE ON perfil_perfil
FOR EACH ROW
EXECUTE PROCEDURE comprobar_amigo();


-- -----------------------------------------------------
-- Antes de INSERTAR/ACTUALIZAR en la TABLA perfil:
-- Impide la inserción un perfil si se pasa del límite de perfiles permitidos
-- PREMIUM = 4 ; BASICA = 1 ; CONTENIDO = 4 ;
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION comprobar_numero_perfiles()
RETURNS trigger AS $comprobar_numero_perfiles$
DECLARE
  t_suscripcion VARCHAR(15);                       -- Tipo de suscripcion
  t_premium CONSTANT VARCHAR(15) := 'Premium';     -- Tipo Premium
  t_contenido CONSTANT VARCHAR(15) := 'Contenido'; -- Max. perfiles suscripcion Contenido
  t_basica CONSTANT VARCHAR(15) := 'Basica';       -- Max. perfiles suscripcion Basica
  premium CONSTANT INT := 4;            -- Max. perfiles suscripcion Premium
  contenido CONSTANT INT := 4;          -- Max. perfiles suscripcion Contenido
  basica CONSTANT INT := 1;             -- Max. perfiles suscripcion Basica
  num_perfiles INT;         -- Total de perfiles
BEGIN
  -- Comprobar si el usuario tiene una suscripción y, si es asi, obtener el tipo
  SELECT tipo_suscripcion INTO t_suscripcion
  FROM suscripcion
  WHERE email=NEW.email AND fecha_finalizacion >= CURRENT_DATE;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Error, El usuario (%) no tiene una suscripcion activa.', NEW.email;
  END IF;

  -- Obtener numero de perfiles del usuario
  SELECT COUNT(*) INTO num_perfiles
  FROM perfil
  WHERE email=NEW.email;

  num_perfiles := num_perfiles + 1;
  -- Comprobar que no se pasa de la cantidad suscrita
  IF (t_suscripcion = t_premium AND num_perfiles > premium) OR
     (t_suscripcion = t_contenido AND num_perfiles > contenido) OR
     (t_suscripcion = t_basica AND num_perfiles > basica) THEN
    RAISE EXCEPTION 'Error, Se excede del número máximo de perfiles (%) que permite tu suscripcion (%)', num_perfiles-1, t_suscripcion;
  END IF;

  RETURN NEW;
END;
$comprobar_numero_perfiles$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_comprobar_numero_perfiles
BEFORE INSERT OR UPDATE ON perfil
FOR EACH ROW
EXECUTE PROCEDURE comprobar_numero_perfiles();



-- -----------------------------------------------------
-- Antes de INSERTAR/ACTUALIZAR en la TABLA suscripcion:
-- Impide que un usuario tenga mas de 1 suscripcion activa
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION comprobar_num_suscripciones_activas()
RETURNS trigger AS $comprobar_num_suscripciones_activas$
DECLARE
  num_suscripciones INT;  -- Numero de suscripciones activas
BEGIN
  -- Si estamos trabajando en una suscrpcion que estará activa, comprabamos que no tenemos mas de 1 activa
  IF NEW.fecha_finalizacion >= CURRENT_DATE THEN
    IF (TG_OP = 'UPDATE') THEN
      SELECT COUNT(*) INTO num_suscripciones
      FROM suscripcion
      WHERE email=NEW.email AND fecha_finalizacion >= CURRENT_DATE AND idSuscripcion != OLD.idSuscripcion;
    ELSE
      SELECT COUNT(*) INTO num_suscripciones
      FROM suscripcion
      WHERE email=NEW.email AND fecha_finalizacion >= CURRENT_DATE;
    END IF;

    IF num_suscripciones > 0 THEN
      RAISE EXCEPTION 'Error, Los usuarios solo pueden tener una suscripcion activa.';
    END IF;
  END IF;

  RETURN NEW;
END;
$comprobar_num_suscripciones_activas$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_num_suscripciones_activas
BEFORE INSERT OR UPDATE ON suscripcion
FOR EACH ROW
EXECUTE PROCEDURE comprobar_num_suscripciones_activas();


-- -----------------------------------------------------
-- Antes de INSERTAR/ACTUALIZAR en la TABLA descargas:
-- Impide que un usuario tenga mas descargas del maximo
-- permitido por sus suscripción actual
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION comprobar_num_descargas()
RETURNS trigger AS $comprobar_num_descargas$
DECLARE
  usuario usuario.email%TYPE; -- email usuario
  num_descargas INT;  -- Numero de descargas activas
  max_descargas INT;  -- Numero maximo de descargas permitidas
BEGIN
  -- Obtenemos el usuario al que pertenece el perfil
  SELECT email INTO usuario
  FROM perfil
  WHERE idPerfil=NEW.idPerfil;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Error al descargar: No existe el usuario asociado al perfil (%).', NEW.idPerfil;
  END IF;

  -- Obtenemos el número max de descargas permitidas
  SELECT num_descargas_max INTO max_descargas
  FROM suscripcion
  WHERE email=usuario AND fecha_finalizacion >= CURRENT_DATE;
  IF NOT FOUND THEN
    RAISE EXCEPTION 'Error al descargar: El usuario (%) no tiene una suscripción activa.', usuario;
  END IF;

  -- Obtenemos el número de descargas totales
  SELECT COUNT(*) INTO num_descargas
  FROM descargas
  WHERE idPerfil IN (SELECT idPerfil
		     FROM perfil
		     WHERE email=usuario);

  -- Comprobamos si no supera el maximo de descargas
  IF (TG_OP = 'INSERT') OR OLD.idPerfil <> NEW.idPerfil THEN
    num_descargas := num_descargas + 1;
  END IF;

  IF num_descargas > max_descargas THEN
    RAISE EXCEPTION 'Error al descargar, se sobrepasa el número maximo de descargas permitidas (%) por la suspcripción.', max_descargas;
  END IF;

  RETURN NEW;
END;
$comprobar_num_descargas$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_comprobar_num_descargas
BEFORE INSERT OR UPDATE ON descargas
FOR EACH ROW
EXECUTE PROCEDURE comprobar_num_descargas();


-- -----------------------------------------------------
-- Despues de INSERTAR/ACTUALIZAR/ELIMINAR en la TABLA descargas:
-- Actualiza el número de descargas
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION actualizar_num_descargas_perfil()
RETURNS trigger AS $actualizar_num_descargas_perfil$
DECLARE
  num_descargas INT;  -- Numero de descargas
BEGIN
  IF TG_OP = 'DELETE' THEN
    -- Obtenemos el número de descargas totales
    SELECT COUNT(*) INTO num_descargas
    FROM descargas
    WHERE idPerfil = OLD.idPerfil;

    -- Actualizamos el numero de descargas totales del perfil
    UPDATE perfil
    SET num_descargas_actuales=num_descargas
    WHERE idPerfil=OLD.idPerfil;

    RETURN OLD;
  END IF;

  -- Obtenemos el número de descargas totales
  SELECT COUNT(*) INTO num_descargas
  FROM descargas
  WHERE idPerfil = NEW.idPerfil;

  -- Actualizamos el numero de descargas totales del perfil
  UPDATE perfil
  SET num_descargas_actuales=num_descargas
  WHERE idPerfil=NEW.idPerfil;

  -- Si se modifica el id del perfil, actualizamos tambien el del otro perfil
  IF TG_OP = 'UPDATE' AND OLD.idPerfil <> NEW.idPerfil THEN
    -- Obtenemos el número de descargas totales
    SELECT COUNT(*) INTO num_descargas
    FROM descargas
    WHERE idPerfil = OLD.idPerfil;

    -- Actualizamos el numero de descargas totales del perfil
    UPDATE perfil
    SET num_descargas_actuales=num_descargas
    WHERE idPerfil=OLD.idPerfil;
  END IF;

  RETURN NEW;
END;
$actualizar_num_descargas_perfil$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_actualizar_num_descargas_perfil
AFTER INSERT OR UPDATE OR DELETE ON descargas
FOR EACH ROW
EXECUTE PROCEDURE actualizar_num_descargas_perfil();



-- -----------------------------------------------------
-- Despues de INSERTAR/MODIFICAR en la TABLA perfil_visualiza_titulo:
-- Si se ha visualizado el titulo y está en descargas, elimina la descarga
-- -----------------------------------------------------
CREATE OR REPLACE FUNCTION eliminar_descarga_titulo_visto()
RETURNS trigger AS $eliminar_descarga_titulo_visto$
DECLARE
  margen CONSTANT INT := 10; -- Margen en minutos, para marcar titulo como visto
  total INT;
BEGIN
  IF NEW.visto THEN
    IF EXISTS (SELECT FROM descargas WHERE idTitulo=NEW.idTitulo AND idPerfil=NEW.idPerfil) THEN
      DELETE FROM descargas WHERE idTitulo=NEW.idTitulo AND idPerfil=NEW.idPerfil;
    END IF;
  END IF;

  RETURN NEW;
END;
$eliminar_descarga_titulo_visto$ LANGUAGE plpgsql;


CREATE TRIGGER trigger_eliminar_descarga_titulo_visto
AFTER INSERT OR UPDATE ON perfil_visualiza_titulo
FOR EACH ROW
EXECUTE PROCEDURE eliminar_descarga_titulo_visto();

/*
SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;
*/
